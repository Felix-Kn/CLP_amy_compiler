package amyc
package codegen

import analyzer._
import amyc.ast.Identifier
import amyc.ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import amyc.utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        val comment = Comment(fd.toString)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          comment <:> body
        }
      }
    }


    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    

    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case IntLiteral(i) =>
          // Push i to the stack.
          // The comments are optional but can help you debug.
          Comment(expr.toString) <:> Const(i)

        case StringLiteral(value) => 
           Comment(expr.toString) <:> mkString(value)

        case BooleanLiteral(value) => 
          Comment(expr.toString) <:> Const(if value then 1 else 0)

        case UnitLiteral() => 
          Comment(expr.toString) <:> Const(0)

        case Variable(name) => Comment(expr.toString) <:> GetLocal(locals.get(name).get)

        // unary operators
        case Not(e) =>
          Comment(expr.toString) <:> 
          cgExpr(e) <:>
          Eqz
        
        case Neg(e) => 
          Comment(expr.toString) <:> 
          cgExpr(e) <:> 
          Const(-1) <:>
          Mul

        // binary operators
        
        case Plus(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Add

        case Minus(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Sub
        
        case Times(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Mul
        
        case AmyDiv(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Div
        
        case Mod(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Rem
        
        case LessThan(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs) <:> cgExpr(rhs) <:>
          Lt_s

        case LessEquals(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Le_s
        
        case AmyAnd(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          And
        
        case AmyOr(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Or

        case Equals(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Eq 
        
        case Concat(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Call("String_concat")
        
        // error 
        case Error(msg) => 
          Comment(expr.toString) <:> 
          cgExpr(msg) <:> 
          Call("Std_printString") <:>
          Unreachable
        

        case AmyCall(qname, args) => 
          table.getFunction(qname) match
            case Some(func) => {
              val argsCode = args.map(cgExpr(_)).reduceLeftOption((l,r) => l<:>r)
              argsCode match
              case None => Comment(expr.toString) <:> Call(fullName(func.owner, qname))
              case Some(value) => Comment(expr.toString) <:> value <:> Call(fullName(func.owner, qname))
            }
            case None => 
              val constructor = table.getConstructor(qname).getOrElse(ctx.reporter.fatal("Name analyzer failed !!"))
              val objectCode = List(Code(List(Const(constructor.index)))) ++ args.map(cgExpr(_))
              val nbI32Towrite = objectCode.size
              val storedObject = for (code, index) <- objectCode.zipWithIndex
                yield GetGlobal(memoryBoundary) <:> Const(index) <:> Add <:> code <:> Store

              val newMemIndex = GetLocal(memoryBoundary) <:> Const(nbI32Towrite) <:> SetGlobal(memoryBoundary)
              storedObject <:> newMemIndex
          
          
        case Sequence(e1, e2) => 
          Comment(expr.toString) <:>
          cgExpr(e1) <:> 
          Drop <:> 
          cgExpr(e2)

                  
        case Ite(cond, thenn, elze) => 
          Comment(expr.toString) <:>
          cgExpr(cond) <:>
          If_i32 <:>
          cgExpr(thenn) <:>
          Else <:>
          cgExpr(elze) <:>
          End
        
        case Let(df, value, body) => 
          val newId = lh.getFreshLocal()
          Comment(expr.toString) <:>
          cgExpr(value) <:>
          SetLocal(newId) <:> 
          cgExpr(body)(locals+(df.name-> newId), lh)



        case Match(scrut, cases) =>

          // Checks if a value matches a pattern.
          // Assumes value is on top of stack (and CONSUMES it)
          // Returns the code to check the value, and a map of bindings.
          def matchAndBind(pat: Pattern): (Code, Map[Identifier, Int]) = pat match {
            case IdPattern(id) =>
              val idLocal = lh.getFreshLocal()
              (Comment(pat.toString) <:> 
              // Assign val to id.
              SetLocal(idLocal) <:> 
              // Return true (IdPattern always matches).
              Const(1),
              // Let the code generation of the expression which corresponds to this pattern
              // know that the bound id is at local idLocal.
              Map(id -> idLocal))
            
            case _ => ???
          }
          ???

      
      }
    }



    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )
  }
}
