package amyc
package codegen

import analyzer._
import amyc.ast.Identifier
import amyc.ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import amyc.utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._


val I32Size = 4

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        val comment = Comment(fd.toString)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          comment <:> body
        }
      }
    }


    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    

    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case IntLiteral(i) =>
          // Push i to the stack.
          // The comments are optional but can help you debug.
          Comment(expr.toString) <:> Const(i)

        case StringLiteral(value) => 
           Comment(expr.toString) <:> mkString(value)

        case BooleanLiteral(value) => 
          Comment(expr.toString) <:> Const(if value then 1 else 0)

        case UnitLiteral() => 
          Comment(expr.toString) <:> Const(0)

        case Variable(name) => Comment(expr.toString) <:> GetLocal(locals.get(name).get)

        // unary operators
        case Not(e) =>
          Comment(expr.toString) <:> 
          cgExpr(e) <:>
          Eqz
        
        case Neg(e) => 
          Comment(expr.toString) <:> 
          cgExpr(e) <:> 
          Const(-1) <:>
          Mul

        // binary operators
        
        case Plus(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Add

        case Minus(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Sub
        
        case Times(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Mul
        
        case AmyDiv(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Div
        
        case Mod(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Rem
        
        case LessThan(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs) <:> cgExpr(rhs) <:>
          Lt_s

        case LessEquals(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs)<:> cgExpr(rhs) <:>
          Le_s
        
        case AmyAnd(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs) <:>
          If_i32 <:>
          cgExpr(rhs) <:>
          Else <:>
          Const(0) <:>
          End
        
        case AmyOr(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs) <:>
          If_i32 <:>
          Const(1) <:>
          Else <:>
          cgExpr(rhs) <:>
          End

        case Equals(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs) <:> cgExpr(rhs) <:>
          Eq 
        
        case Concat(lhs, rhs) => 
          Comment(expr.toString) <:>
          cgExpr(lhs) <:> cgExpr(rhs) <:>
          Call("String_concat")
        
        // error 
        case Error(msg) => 
          Comment(expr.toString) <:> 
          cgExpr(msg) <:> 
          Call("Std_printString") <:>
          Unreachable
        

        case AmyCall(qname, args) => 
          table.getFunction(qname) match
            case Some(func) => {
              val argsCode = args.map(cgExpr(_)).reduceLeftOption((l,r) => l<:>r)
              argsCode match
              case None => Comment(expr.toString) <:> Call(fullName(func.owner, qname))
              case Some(value) => Comment(expr.toString) <:> value <:> Call(fullName(func.owner, qname))
            }
            case None => 

              val startAdrId = lh.getFreshLocal()
              val startAdr = GetGlobal(memoryBoundary) <:> SetLocal(startAdrId)

              val constructor = table.getConstructor(qname).get
              val objectCode = List(Code(List(Const(constructor.index)))) ++ args.map(cgExpr(_))
              val nbI32Towrite = objectCode.size
             
              

              val storedObject = for (code, index) <- objectCode.zipWithIndex
                yield GetLocal(startAdrId) <:> 
                      Const(index*I32Size) <:>
                      Add <:> 
                      code <:>
                      Store

              val newMemIndex = GetLocal(startAdrId) <:>
                                Const(nbI32Towrite*I32Size) <:> 
                                Add <:> 
                                SetGlobal(memoryBoundary)

              Comment(expr.toString) <:> startAdr <:> newMemIndex <:> storedObject <:> GetLocal(startAdrId)
          
          
        case Sequence(e1, e2) => 
          Comment(expr.toString) <:>
          cgExpr(e1) <:> 
          Drop <:> 
          cgExpr(e2)

                  
        case Ite(cond, thenn, elze) => 
          Comment(expr.toString) <:>
          cgExpr(cond) <:>
          If_i32 <:>
          cgExpr(thenn) <:>
          Else <:>
          cgExpr(elze) <:>
          End
        
        case Let(df, value, body) => 
          val newId = lh.getFreshLocal()
          Comment(expr.toString) <:>
          cgExpr(value) <:>
          SetLocal(newId) <:> 
          cgExpr(body)(locals+(df.name-> newId), lh)

        case Assign(df, value, body) => 
            val newId = lh.getFreshLocal()
            Comment(expr.toString) <:>
            cgExpr(value) <:>
            SetLocal(newId) <:> 
            cgExpr(body)(locals+(df.name-> newId), lh)
        
        case reAssign(name, newValue) => 
          Comment(expr.toString) <:>
          cgExpr(newValue) <:>
          SetLocal(locals.get(name).get) <:> 
          Const(0) // return Unit

        case While(cond, body) =>
          val loopName = getFreshLabel("Start_while")
          val blockName = getFreshLabel("End_while")
          Comment(expr.toString) <:>
          Block(blockName) <:> 
            Loop(loopName) <:> 
              cgExpr(cond) <:>
              Eqz <:>
              If_void <:> Br(blockName) <:> End <:>
              cgExpr(body) <:> Drop <:> Br(loopName) <:>
            End <:>
          End <:> Const(0) // return Unit
            
          

        case Match(scrut, cases) =>
            
          // Checks if a value matches a pattern.
          // Assumes value is on top of stack (and CONSUMES it)
          // Returns the code to check the value, and a map of bindings.
          def matchAndBind(pat: Pattern): (Code, Map[Identifier, Int]) = pat match {
            case WildcardPattern() =>
              (Comment(pat.toString) <:> 
              Drop <:> 
              Const(1), Map())

            case IdPattern(id) =>
              val idLocal = lh.getFreshLocal()
              (Comment(pat.toString) <:> 
              // Assign val to id.
              SetLocal(idLocal) <:> 
              // Return true (IdPattern always matches).
              Const(1),
              // Let the code generation of the expression which corresponds to this pattern
              // know that the bound id is at local idLocal.
              Map(id -> idLocal))

            case LiteralPattern(lit) => 
              (Comment(pat.toString) <:> 
              cgExpr(lit) <:> // generate literal value
              Eq,// compare I32 to match
              Map())
            
            case CaseClassPattern(constr, patterns) => 
              val caseClassCons = table.getConstructor(constr).get

              val blockLabel = getFreshLabel("End_pattern")
              val isMatchId = lh.getFreshLocal()
              val startAdrId = lh.getFreshLocal()
              val matchLenght = patterns.size + 1 // check Constr index + every field in the CaseClass

              val startAdr = SetLocal(startAdrId) // Adt address
              val isMatch = Const(1) <:> SetLocal(isMatchId)
              val startCode = startAdr <:> isMatch <:> Block(blockLabel)

              val (eqChecks, newIds) = patterns.map(matchAndBind(_)).unzip
              val loadAndCheck = (Code(List(Const(caseClassCons.index), Eq)) +:eqChecks)
                .zipWithIndex
                .map((checkCode, index) => 
                  GetLocal(startAdrId) <:> Const(index*I32Size) <:> Add <:> 
                  Load <:> 
                  checkCode <:> 
                  Eqz <:> If_void <:> Const(0) <:> SetLocal(isMatchId) <:> Br(blockLabel) <:> Else <:> End 
                )
              (startCode <:> loadAndCheck <:> End <:> GetLocal(isMatchId), newIds.fold(Map.empty[Identifier, Int])(_++_)) 
  
          }

          val matchOnCode = cgExpr(scrut)
          val matchOnValId = lh.getFreshLocal()
          val temp = lh.getFreshLocal() 

          val matchBlockName = getFreshLabel("Pattern_Matched")
          val BlockEnd = Block(matchBlockName)
          val startCode = matchOnCode <:> SetLocal(matchOnValId) <:> BlockEnd

          def generateIfClause(l: List[((Code, Map[Identifier, Int]), Expr)]): Code = {
            l match
              case ((c, m), e) :: next => 
                GetLocal(matchOnValId) <:> c <:> 
                If_void <:> cgExpr(e)(locals++m, lh) <:> SetLocal(temp) <:> Br(matchBlockName) <:> Else <:>
                generateIfClause(next) <:> End

              case Nil => Code(List(Const(0), SetLocal(temp), Unreachable)) // make the program fail if no match succeed
          }
          val caseList = cases.map(x => (matchAndBind(x.pat), x.expr))
          startCode <:> generateIfClause(caseList) <:> End <:> GetLocal(temp)
      }
    }


    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )
  }
}
